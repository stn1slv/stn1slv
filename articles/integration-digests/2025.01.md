## Articles

üîç [Build API clients with Microsoft Kiota](https://www.infoworld.com/article/3803379/build-api-clients-with-microsoft-kiota.html)

_Project Kiota is a Microsoft tool that automates API client development using OpenAPI definitions, supporting multiple programming languages and toolchains. The tool simplifies development by generating standardized client code from API descriptions, eliminating the need to learn different REST libraries for each language while providing basic tools for JSON payload handling and allowing developers to specify which elements of an OpenAPI description to implement._

üîç [OpenAPI is hard](https://quobix.com/articles/openapi-is-hard/)

_This article discusses the complexity of working with OpenAPI and explains why building tools to handle OpenAPI specifications is surprisingly challenging. It describes the author's journey in creating a sophisticated system called the OpenAPI Doctor that can effectively handle complex OpenAPI specifications, including features like reference navigation and visualization, while explaining that OpenAPI's complexity stems from it being a composite of multiple languages and standards like YAML, JSON, and JSON Schema._

üîç [Optimizing Large Payloads for Sync/Async Communications](https://arvind4gl.medium.com/optimizing-large-payloads-for-sync-async-communications-fc71eacb6179)

_The article discusses optimization strategies for handling large payloads in both synchronous and asynchronous communication patterns in microservices architecture. It provides detailed technical implementations for optimizing data transfer in Spring Boot using techniques like HTTP compression, pagination, and streaming, while also covering Kafka/RabbitMQ optimization strategies such as payload chunking, compression, and external storage solutions._

üîç [Save edits to OpenAPI as an Overlay](https://lornajane.net/posts/2025/save-edits-to-openapi-as-an-overlay)

_The article explains how OpenAPI Overlay Specification allows teams to maintain and preserve changes made to generated OpenAPI files without losing them during regeneration. It describes how overlays can store amendments to OpenAPI documents and demonstrates how to create and apply them using tools like Speakeasy CLI, enabling teams to maintain rich content while working with generated API documentation._

üîç [The MOIST Principle for GraphQL Schema Design](https://magiroux.com/moist-principle)

_The article discusses the MOIST (Mitigate the Overuse of Illusory Shared Types) principle for GraphQL schema design, arguing against excessive type sharing in favor of more specific, context-appropriate types. It explains that while sharing types may seem beneficial for consistency and maintenance, it can lead to problems with API evolution and authorization, suggesting that writing separate types for different contexts is often better than forcing shared types across an API._

üîç [The best API conferences to attend in 2025](https://tyk.io/blog/best-api-conferences/)

_The article presents a comprehensive overview of major API conferences scheduled for 2025, including events like API World, KubeCon, and various apidays conferences across global locations from Singapore to Paris._

üîç [The Top 10 Mistakes Developers Make When Writing APIs (And How to Fix Them)](https://dev.to/balrajola/the-top-10-mistakes-developers-make-when-writing-apis-and-how-to-fix-them-ng3)

_This article outlines the ten most common mistakes developers make when creating APIs, including poor documentation, lack of versioning, inadequate error handling, and insufficient security measures, while providing practical solutions and best practices for each issue to help developers build more robust and user-friendly APIs._

üîç [Wherefore HATEOAS](https://apidesignmatters.substack.com/p/wherefore-hateoas)

_The article discusses Hypermedia as the Engine of Application State (HATEOAS) in API design, explaining how it enables API capabilities through embedded hypermedia links in responses and allows for better decoupling between client and server. While HATEOAS works well for web applications with dynamic states and business rules managed on the backend, it presents challenges for general-purpose APIs and requires complex client implementations to handle dynamic features effectively._

üîç [Working with AsyncAPI documents locally](https://www.brainfart.dev/blog/asyncapi-local-setup)

_The article discusses various tools and approaches for working with AsyncAPI documents locally, emphasizing the benefits of minimal, local setups over cloud-based solutions. It explores three main options: using a plain IDE with SchemaStore integration, installing specific IDE plugins/extensions for AsyncAPI, and utilizing the AsyncAPI CLI, with each approach offering different levels of functionality for validation, preview, and document management._

### Apache Kafka

üîç [Kafka Streams 101: Windows & Time](https://www.responsive.dev/blog/windows-and-time-kafka-streams-101)

_The article explains the concept of time and windowing in Kafka Streams, covering three types of time (Stream Time, Event Time, and Wall Time) and four types of windows (Tumbling, Hopping, Session, and Sliding). It details how these windows handle data aggregation differently and explains how late-arriving records are managed through grace periods, while also providing guidance on Time to Live (TTL) implementation and handling out-of-order events._

üîç [How Does Kafka Log Compaction Work?](https://www.nootcode.com/knowledge/en/kafka-log-compaction)

_Kafka Log Compaction is a data retention mechanism that preserves the most recent value for each message key while removing outdated values, making it particularly useful for maintaining current state data like database changes or configuration settings. The process works by dividing logs into clean and dirty segments, where the compaction process scans through messages and preserves only the latest records for each key while maintaining the original message sequence._

üîç [Why is Apache Kafka¬Æ Tiered Storage more like a dam than a fountain? Part 3: Kafka time and space](https://www.instaclustr.com/blog/apache-kafka-tiered-storage-part-3/)

_The article explores Apache Kafka's relationship with time and space, discussing how the system handles different temporal aspects like event time, ingestion time, and processing time, as well as its ability to enable time travel through record replay and seeking capabilities. It delves into how Kafka's tiered storage architecture allows for storing more historical data on cloud storage, enabling access to older records while managing space efficiently through various retention policies and consumer behaviors._

üîç [Why is Apache Kafka¬Æ Tiered Storage more like a dam than a fountain? Part 4: Tiered Storage use cases](https://www.instaclustr.com/blog/apache-kafka-tiered-storage-part-4/)

_The article discusses Kafka Tiered Storage architecture and its various use cases, focusing on how different consumer behaviors impact data processing and storage requirements. It explores scenarios from real-time processing to slow consumers, disconnected consumers, and record replaying capabilities, while explaining how Kafka's ability to store older records on cloud-native storage enables longer retention periods and new use cases like event sourcing and cluster migration._

### Mulesoft

üîç [DataWeave Done Right: Best Practices for Reusability](https://medium.com/another-integration-blog/dataweave-done-right-best-practices-for-reusability-fa7ce347d068)

_This article discusses best practices for creating reusable code in DataWeave, MuleSoft's scripting language, focusing on functions, modules, and dynamic flow references to enhance code efficiency and maintainability. The article provides practical examples and guidelines for implementing reusable components, including proper function naming, module organization, and avoiding common pitfalls while emphasizing the importance of code documentation and simplicity._

### WSO2

üîç [Introducing Database Connections in Choreo](https://wso2.com/library/blogs/introducing-database-connections-choreo/)

_Choreo's new database connections feature streamlines application-database connectivity by automating parameter management and offering environment-specific configurations. The feature simplifies database integration by providing automated parameter injection, environment-specific credentials, and secure access control, while reducing manual effort and configuration errors in the process._

## Releases

üöÄ [Gravitee 4.6](https://www.gravitee.io/blog/gravitee-4.6-release-overview)

_Gravitee 4.6 introduces several major enhancements including the Gravitee Kafka Gateway for managing Kafka infrastructure, improved secrets management capabilities, and OpenTelemetry support for better observability. The release focuses on strengthening security, improving API governance, and bridging traditional APIs with modern event systems while offering new features like API Score for automated governance and enhanced subscription management through the Gravitee Kubernetes Operator._

üöÄ [Microcks 1.11](https://microcks.io/blog/microcks-1.11.0-release/)

_The Microcks 1.11.0 release brings enhanced validation capabilities for mocks with new input request controls and gRPC error management, as well as major improvements to software supply chain security including automated release processes, SBOM generation, and package signing. This substantial update includes over 60 resolved issues and contributions from 12 developers, making it one of the project's largest releases to date._